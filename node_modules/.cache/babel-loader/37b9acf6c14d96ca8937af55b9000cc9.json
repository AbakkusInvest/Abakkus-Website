{"ast":null,"code":"import * as React from 'react';\nimport { useConst } from './useConst';\nimport { useConstCallback } from './useConstCallback';\nexport function useControllableValue(controlledValue, defaultUncontrolledValue, onChange) {\n  var _a = React.useState(defaultUncontrolledValue),\n      value = _a[0],\n      setValue = _a[1];\n\n  var isControlled = useConst(controlledValue !== undefined);\n  var currentValue = isControlled ? controlledValue : value; // Duplicate the current value and onChange in refs so they're accessible from\n  // setValueOrCallOnChange without creating a new callback every time\n\n  var valueRef = React.useRef(currentValue);\n  var onChangeRef = React.useRef(onChange);\n  React.useEffect(function () {\n    valueRef.current = currentValue;\n    onChangeRef.current = onChange;\n  }); // To match the behavior of the setter returned by React.useState, this callback's identity\n  // should never change. This means it MUST NOT directly reference variables that can change.\n\n  var setValueOrCallOnChange = useConstCallback(function (update, ev) {\n    // Assuming here that TValue is not a function, because a controllable value will typically\n    // be something a user can enter as input\n    var newValue = typeof update === 'function' ? update(valueRef.current) : update;\n\n    if (onChangeRef.current) {\n      onChangeRef.current(ev, newValue);\n    }\n\n    if (!isControlled) {\n      setValue(newValue);\n    }\n  });\n  return [currentValue, setValueOrCallOnChange];\n}","map":{"version":3,"sources":["useControllableValue.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SAAS,QAAT,QAAyB,YAAzB;AACA,SAAS,gBAAT,QAAiC,oBAAjC;AAiCA,OAAM,SAAU,oBAAV,CAIJ,eAJI,EAIiC,wBAJjC,EAI+E,QAJ/E,EAImG;AACjG,MAAA,EAAA,GAAA,KAAA,CAAA,QAAA,CAAA,wBAAA,CAAA;AAAA,MAAC,KAAA,GAAA,EAAA,CAAA,CAAA,CAAD;AAAA,MAAQ,QAAA,GAAA,EAAA,CAAA,CAAA,CAAR;;AACN,MAAM,YAAY,GAAG,QAAQ,CAAU,eAAe,KAAK,SAA9B,CAA7B;AACA,MAAM,YAAY,GAAG,YAAY,GAAG,eAAH,GAAqB,KAAtD,CAHuG,CAKvG;AACA;;AACA,MAAM,QAAQ,GAAG,KAAK,CAAC,MAAN,CAAa,YAAb,CAAjB;AACA,MAAM,WAAW,GAAG,KAAK,CAAC,MAAN,CAAa,QAAb,CAApB;AACA,EAAA,KAAK,CAAC,SAAN,CAAgB,YAAA;AACd,IAAA,QAAQ,CAAC,OAAT,GAAmB,YAAnB;AACA,IAAA,WAAW,CAAC,OAAZ,GAAsB,QAAtB;AACD,GAHD,EATuG,CAcvG;AACA;;AACA,MAAM,sBAAsB,GAAG,gBAAgB,CAC7C,UAAC,MAAD,EAAmD,EAAnD,EAAiF;AAC/E;AACA;AACA,QAAM,QAAQ,GAAG,OAAO,MAAP,KAAkB,UAAlB,GAAgC,MAAmB,CAAC,QAAQ,CAAC,OAAV,CAAnD,GAAwE,MAAzF;;AAEA,QAAI,WAAW,CAAC,OAAhB,EAAyB;AACvB,MAAA,WAAW,CAAC,OAAZ,CAAoB,EAApB,EAAyB,QAAzB;AACD;;AAED,QAAI,CAAC,YAAL,EAAmB;AACjB,MAAA,QAAQ,CAAC,QAAD,CAAR;AACD;AACF,GAb4C,CAA/C;AAgBA,SAAO,CAAC,YAAD,EAAe,sBAAf,CAAP;AACD","sourcesContent":["import * as React from 'react';\nimport { useConst } from './useConst';\nimport { useConstCallback } from './useConstCallback';\n\nexport type ChangeCallback<TElement extends HTMLElement, TValue> = (\n  ev: React.FormEvent<TElement> | undefined,\n  newValue: TValue | undefined,\n) => void;\n\n/**\n * Hook to manage a value that could be either controlled or uncontrolled, such as a checked state or\n * text box string.\n * @param controlledValue - The controlled value passed in the props. This value will always be used if provided,\n * and the internal state will be updated to reflect it.\n * @param defaultUncontrolledValue - Initial value for the internal state in the uncontrolled case.\n * @returns An array of the current value and an updater callback. Like `React.useState`, the updater\n * callback always has the same identity, and it can take either a new value, or a function which\n * is passed the previous value and returns the new value.\n * @see https://reactjs.org/docs/uncontrolled-components.html\n */\nexport function useControllableValue<TValue, TElement extends HTMLElement>(\n  controlledValue: TValue | undefined,\n  defaultUncontrolledValue: TValue | undefined,\n): Readonly<[TValue | undefined, (update: React.SetStateAction<TValue | undefined>) => void]>;\nexport function useControllableValue<\n  TValue,\n  TElement extends HTMLElement,\n  TCallback extends ChangeCallback<TElement, TValue> | undefined\n>(\n  controlledValue: TValue | undefined,\n  defaultUncontrolledValue: TValue | undefined,\n  onChange: TCallback,\n): Readonly<\n  [TValue | undefined, (update: React.SetStateAction<TValue | undefined>, ev?: React.FormEvent<TElement>) => void]\n>;\nexport function useControllableValue<\n  TValue,\n  TElement extends HTMLElement,\n  TCallback extends ChangeCallback<TElement, TValue> | undefined\n>(controlledValue: TValue | undefined, defaultUncontrolledValue: TValue | undefined, onChange?: TCallback) {\n  const [value, setValue] = React.useState<TValue | undefined>(defaultUncontrolledValue);\n  const isControlled = useConst<boolean>(controlledValue !== undefined);\n  const currentValue = isControlled ? controlledValue : value;\n\n  // Duplicate the current value and onChange in refs so they're accessible from\n  // setValueOrCallOnChange without creating a new callback every time\n  const valueRef = React.useRef(currentValue);\n  const onChangeRef = React.useRef(onChange);\n  React.useEffect(() => {\n    valueRef.current = currentValue;\n    onChangeRef.current = onChange;\n  });\n\n  // To match the behavior of the setter returned by React.useState, this callback's identity\n  // should never change. This means it MUST NOT directly reference variables that can change.\n  const setValueOrCallOnChange = useConstCallback(\n    (update: React.SetStateAction<TValue | undefined>, ev?: React.FormEvent<TElement>) => {\n      // Assuming here that TValue is not a function, because a controllable value will typically\n      // be something a user can enter as input\n      const newValue = typeof update === 'function' ? (update as Function)(valueRef.current) : update;\n\n      if (onChangeRef.current) {\n        onChangeRef.current(ev!, newValue);\n      }\n\n      if (!isControlled) {\n        setValue(newValue);\n      }\n    },\n  );\n\n  return [currentValue, setValueOrCallOnChange] as const;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}